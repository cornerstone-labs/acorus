package main

import (
	json2 "encoding/json"
	"fmt"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
)

type A interface {
	StartUnpack()
}

type B struct {
	b string
}

func (b *B) StartUnpack() {
	fmt.Println("B: Start" + b.b)
	// B 的 Start 方法逻辑
}

type C struct {
	// C 的字段
	c string
}

func (c *C) StartUnpack() {
	fmt.Println("C: Start" + c.c)
	c.ss()
	// C 的 Start 方法逻辑
}

func (c *C) ss() {
	fmt.Println("ss")
}

func main() {
	//objMap := make(map[string]A)
	//
	//b := &B{"123"}
	//c := &C{"456"}
	//
	//objMap["B"] = b
	//objMap["C"] = c
	//
	//for _, obj := range objMap {
	//	obj.StartUnpack()
	//}
	eventLog := "0xb9025d7b2261646472657373223a22307861306238363939316336323138623336633164313964346132653965623063653336303665623438222c22746f70696373223a5b22307864646632353261643162653263383962363963326230363866633337386461613935326261376631363363346131313632386635356134646635323362336566222c22307830303030303030303030303030303030303030303030303039396263393934366133646235333837323035666463613539373234313335326232613135383464222c22307830303030303030303030303030303030303030303030303062313138666439383532656336373632656433383739396362343366306164316630643239613265225d2c2264617461223a22307830303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303032316437366130373330222c22626c6f636b4e756d626572223a22307831323237313935222c227472616e73616374696f6e48617368223a22307866643931616630663235303432633132393835346161643362316461313330643133376238316663646231636236323235633137316335303239663165386432222c227472616e73616374696f6e496e646578223a2230783866222c22626c6f636b48617368223a22307830383263323338383636663964623638363439646636623061663162303839306464343534393032656463626239633133656662333931343238633463623230222c226c6f67496e646578223a223078313363222c2272656d6f766564223a66616c73657d"
	b, err := hexutil.Decode(eventLog)
	if err != nil {
		fmt.Println(err)
	}

	var result types.Log
	var rlpLog []byte
	if err := rlp.DecodeBytes(b, &rlpLog); err != nil {
		fmt.Println(err)
	}
	json2.Unmarshal(rlpLog, &result)
	fmt.Println(string(rlpLog))
	fmt.Println(result.BlockNumber)

	headerstr := "0xb905817b22706172656e7448617368223a22307834623033343062646431646332636239373335656362303133663562353663333430323963303235373631363239393964343530633439386437316661303232222c2273686133556e636c6573223a22307831646363346465386465633735643761616238356235363762366363643431616433313234353162393438613734313366306131343266643430643439333437222c226d696e6572223a22307835313234666363326233663939663537316164363764303735363433633734336633386631633334222c227374617465526f6f74223a22307831643335376364383230666331623362343138633234613639313736666439313365623362373732616239383961313537303335313032623430393639313065222c227472616e73616374696f6e73526f6f74223a22307866353133633365383030646636393932316162383735383566626564336332353064333563616138363663383838366539363863313664653634373138613130222c227265636569707473526f6f74223a22307865383339393361303732376331666638633261336138656336613564383230303865656230333631626431633332633032316662393939353863383932616266222c226c6f6773426c6f6f6d223a2230783035653934393863343730343034363631393335333066663837353036313230313036323630303839346663303032333038393735303034666330323538383736626130303436316434323030623863323039323838303230633530303134333036383730623430633935363263393130363530313732323030326433383030316561323031633930353034643930646239373666323166363534613230613430383130323038386339343030383138383431343062393438326239306134306237633163313530316163323038343334383630353438306330613132646134303037336361323838393163366332653234303538313131383062633534303031306332393135393039363634393631303965346639363030333732303332363030613061353031346664313230646430303936313034396331333839306532386539363334353234326538323865666132303630396630313031613435303430343138383036353561616431356565363835333935363035303038326131313465396132656632633135623039343133393530306365313134313633393563343932363162353230316138373831386661333835353137303464623238363332613561323830383732393634366432386238633038303862383132343438656330306131313130316238653565343831353038356138313431323434643135222c22646966666963756c7479223a302c226e756d626572223a31383331303939372c226761734c696d6974223a33303030303030302c2267617355736564223a31333830333933322c2274696d657374616d70223a313639363833313239352c22657874726144617461223a225a6a46694c6d6c76222c226d697848617368223a22307830323832326231363538363938373937306166646332636262303830303964613363616665366265303735613934386135646439623638366331663064336663222c226e6f6e6365223a22307830303030303030303030303030303030222c2262617365466565506572476173223a363138323932303138322c227769746864726177616c73526f6f74223a22307835373764663930613438643231313466383464306432393937633639643133363431653162623234303733636433623663633261303063653965636235356230222c22626c6f6247617355736564223a6e756c6c2c22657863657373426c6f62476173223a6e756c6c2c22706172656e74426561636f6e426c6f636b526f6f74223a6e756c6c7d"
	h, _ := hexutil.Decode(headerstr)

	var header types.Header
	var helog []byte
	if err := rlp.DecodeBytes(h, &helog); err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(helog))
	err = json2.Unmarshal(helog, &header)
	fmt.Println(err)
	//hexutil.Encode()
	fmt.Println(header.Number.String())
}
